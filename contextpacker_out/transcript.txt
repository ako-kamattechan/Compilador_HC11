PROJECT TRANSCRIPT: Compilador_HC11
Generated by ContextPacker
==================================================

Directory Tree:
Project: Compilador_HC11
├── .pytest_cache
│   ├── .gitignore
│   ├── CACHEDIR.TAG
│   ├── README.md
│   └── v
│       └── cache
│           ├── lastfailed
│           └── nodeids
├── README.md
├── docs
│   ├── TASKS.html
│   └── TASKS.md
├── error.log
├── pyproject.toml
├── src
│   └── hc11cc
│       ├── __init__.py
│       ├── backend
│       │   ├── __init__.py
│       │   └── hc11
│       │       ├── __init__.py
│       │       ├── emit.py
│       │       ├── isa.py
│       │       ├── isel.py
│       │       └── program.py
│       ├── config.py
│       ├── driver.py
│       ├── errores.py
│       ├── frontend
│       │   ├── __init__.py
│       │   ├── ast_nodes.py
│       │   ├── lexer.py
│       │   ├── parser.py
│       │   ├── sema.py
│       │   └── tokens.py
│       └── ir
│           ├── __init__.py
│           ├── builder.py
│           ├── emit.py
│           └── ir.py
├── tests
│   ├── conftest.py
│   ├── integracion
│   │   └── test_pipeline_smoke.py
│   ├── miembro1_frontend
│   │   └── test_frontend_smoke.py
│   ├── miembro2_ir
│   │   └── test_ir_smoke.py
│   ├── miembro3_backend
│   │   └── test_backend_smoke.py
│   ├── test_lexer.py
│   └── test_parser.py
└── tools
    ├── OPCIONAL.md
    └── Visualizador_Compilador_HC11.html

==================================================

File: .pytest_cache\.gitignore
[
# Created by pytest automatically.
*

]
----------------------------------------
File: .pytest_cache\CACHEDIR.TAG
[
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html

]
----------------------------------------
File: .pytest_cache\README.md
[
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

]
----------------------------------------
File: .pytest_cache\v\cache\lastfailed
[
{}
]
----------------------------------------
File: .pytest_cache\v\cache\nodeids
[
[
  "tests/integracion/test_pipeline_smoke.py::test_pipeline_smoke",
  "tests/miembro1_frontend/test_frontend_smoke.py::test_frontend_smoke",
  "tests/miembro2_ir/test_ir_smoke.py::test_ir_smoke",
  "tests/miembro3_backend/test_backend_smoke.py::test_backend_smoke",
  "tests/test_lexer.py::test_lexer_error_unexpected_char",
  "tests/test_lexer.py::test_lexer_fn_main",
  "tests/test_lexer.py::test_lexer_let_assign",
  "tests/test_lexer.py::test_lexer_spans",
  "tests/test_parser.py::test_parse_source_api",
  "tests/test_parser.py::test_parser_basic_return",
  "tests/test_parser.py::test_parser_error_missing_semicolon",
  "tests/test_parser.py::test_parser_error_missing_type",
  "tests/test_parser.py::test_parser_expr_precedence",
  "tests/test_parser.py::test_parser_let_var",
  "tests/test_parser.py::test_parser_parentheses"
]
]
----------------------------------------
File: README.md
[

]
----------------------------------------
File: docs\TASKS.html
[
<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>hc11cc_py — Tasklist</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1621; --panel2:#0c121b;
      --grid:#1a2635; --text:#e7eef7; --muted:#9bb0c7;
      --accent:#6aa6ff; --ok:#7ad69a; --warn:#ffcf5a; --bad:#ff6a6a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    *{box-sizing:border-box}
    body{margin:0; background:linear-gradient(180deg,#070a0f 0%,#0b0f14 100%); color:var(--text); font-family:var(--sans);}
    header{
      position:sticky; top:0; z-index:10;
      background:rgba(11,15,20,.85); backdrop-filter: blur(10px);
      border-bottom:1px solid rgba(26,38,53,.8);
    }
    .wrap{max-width:1100px; margin:0 auto; padding:18px 16px;}
    h1{margin:0; font-size:18px; letter-spacing:.2px;}
    .sub{margin-top:6px; color:var(--muted); font-size:13px; line-height:1.35;}
    .controls{
      margin-top:14px; display:grid; grid-template-columns: 1fr auto auto auto; gap:10px;
      align-items:center;
    }
    .search, .select, button{
      border:1px solid rgba(26,38,53,.95);
      background:rgba(15,22,33,.85);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      outline:none;
      box-shadow: 0 0 0 rgba(0,0,0,0);
      transition: border-color .15s ease, transform .05s ease;
      font-size:14px;
    }
    .search::placeholder{color:rgba(155,176,199,.65)}
    .search:focus, .select:focus, button:focus{border-color:rgba(106,166,255,.85)}
    button{cursor:pointer; user-select:none}
    button:active{transform: translateY(1px)}
    main .wrap{padding-top:14px; padding-bottom:38px;}
    .grid{display:grid; grid-template-columns: 1fr; gap:14px;}
    @media (min-width: 980px){
      .grid{grid-template-columns: 1fr 1fr;}
      .span2{grid-column: 1 / -1;}
    }
    .card{
      background:linear-gradient(180deg, rgba(15,22,33,.92), rgba(12,18,27,.92));
      border:1px solid rgba(26,38,53,.95);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card header{
      position:static;
      background:transparent;
      border-bottom:1px solid rgba(26,38,53,.65);
      padding:14px 14px 12px 14px;
    }
    .card h2{margin:0; font-size:15px;}
    .card .meta{margin-top:6px; color:var(--muted); font-size:12px; line-height:1.35;}
    .card .body{padding:12px 14px 14px 14px;}
    .task{
      display:grid;
      grid-template-columns: 22px 1fr;
      gap:10px;
      padding:9px 10px;
      border-radius:12px;
      border:1px solid transparent;
      background:rgba(11,15,20,.35);
      margin:8px 0;
    }
    .task:hover{border-color:rgba(26,38,53,.7); background:rgba(11,15,20,.55)}
    .task input{margin-top:2px; width:18px; height:18px; accent-color: var(--accent);}
    .task .txt{font-size:14px; line-height:1.25;}
    .task .path{display:block; margin-top:6px; font-family:var(--mono); font-size:12px; color:rgba(155,176,199,.9)}
    .task.done .txt{color:rgba(231,238,247,.75); text-decoration: line-through; text-decoration-thickness: 2px;}
    .task.done .path{color:rgba(155,176,199,.55)}
    .small{font-size:12px; color:var(--muted); line-height:1.35}
    .bar{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(26,38,53,.65);
      background:rgba(11,15,20,.4);
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(26,38,53,.8);
      background:rgba(15,22,33,.6);
      color:var(--muted);
      font-size:12px;
      user-select:none;
    }
    .dot{width:8px; height:8px; border-radius:999px; background:var(--warn);}
    .dot.ok{background:var(--ok)}
    .dot.bad{background:var(--bad)}
    footer{border-top:1px solid rgba(26,38,53,.8); background:rgba(11,15,20,.6)}
    footer .wrap{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;}
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    .kbd{font-family:var(--mono); font-size:12px; color:rgba(231,238,247,.8)}
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>hc11cc_py — Tasklist</h1>
    <div class="sub">
      Vista visual de tareas por integrante y por fase. El estado se guarda localmente en este navegador.
      <span class="kbd">Búsqueda</span> filtra por texto, archivo o ruta.
    </div>

    <div class="controls">
      <input id="search" class="search" placeholder="Buscar (ej. lexer, builder, backend, pytest -m ir)..." />
      <select id="scope" class="select" title="Filtrar por área">
        <option value="all">Todas las áreas</option>
        <option value="frontend">Frontend</option>
        <option value="ir">IR</option>
        <option value="backend">Backend</option>
        <option value="integracion">Integración</option>
      </select>
      <button id="collapseAll" type="button" title="Colapsar/expandir">Colapsar</button>
      <button id="reset" type="button" title="Borrar progreso local">Reiniciar</button>
    </div>

    <div class="bar" style="margin-top:12px;">
      <div class="pill"><span class="dot" id="dotGlobal"></span><span id="progressGlobal">0/0 completadas</span></div>
      <div class="small">
        Ejecutar suites:
        <span class="kbd">pytest -m frontend</span>,
        <span class="kbd">pytest -m ir</span>,
        <span class="kbd">pytest -m backend</span>,
        <span class="kbd">pytest -m integracion</span>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="wrap">
    <div class="grid" id="cards"></div>
  </div>
</main>

<footer>
  <div class="wrap">
    <div class="small">
      Archivo sugerido: <span class="kbd">TASKS.html</span> dentro del repo. Estado guardado en <span class="kbd">localStorage</span>.
    </div>
    <div class="small">
      Atajos: <span class="kbd">Ctrl/Cmd + F</span> (buscar en página), <span class="kbd">Esc</span> (limpiar búsqueda).
    </div>
  </div>
</footer>

<script>
  // ----------------------------
  // Data model (editable)
  // ----------------------------
  const DATA = [
    {
      id: "frontend",
      titulo: "Integrante 1 — Frontend (lenguaje → AST)",
      meta: [
        "Carpeta: src/hc11cc/frontend/",
        "Tests: pytest -m frontend",
        "Contrato: producir AST válido; no conoce HC11"
      ],
      tareas: [
        { id:"fe-lex-1", texto:"Implementar tokens: fn, main, let, return, u8", path:"src/hc11cc/frontend/lexer.py" },
        { id:"fe-lex-2", texto:"Implementar símbolos: ->, :, =, +, -, (), {}, ;", path:"src/hc11cc/frontend/lexer.py" },
        { id:"fe-lex-3", texto:"Implementar literales enteros 0..255 e identificadores", path:"src/hc11cc/frontend/lexer.py" },

        { id:"fe-par-1", texto:"Parsear función única main", path:"src/hc11cc/frontend/parser.py" },
        { id:"fe-par-2", texto:"Parsear let x: u8 = <expr>;", path:"src/hc11cc/frontend/parser.py" },
        { id:"fe-par-3", texto:"Parsear return <expr>;", path:"src/hc11cc/frontend/parser.py" },
        { id:"fe-par-4", texto:"Parsear expresiones + y - con paréntesis", path:"src/hc11cc/frontend/parser.py" },

        { id:"fe-sema-1", texto:"Validar tipos u8", path:"src/hc11cc/frontend/sema.py" },
        { id:"fe-sema-2", texto:"Error si literal > 255", path:"src/hc11cc/frontend/sema.py" },
        { id:"fe-sema-3", texto:"Error si variable no existe", path:"src/hc11cc/frontend/sema.py" },
        { id:"fe-sema-4", texto:"Error si variable se redeclara", path:"src/hc11cc/frontend/sema.py" },

        { id:"fe-test-1", texto:"Endurecer casos válidos e inválidos", path:"tests/miembro1_frontend/test_frontend_smoke.py" },
      ]
    },
    {
      id: "ir",
      titulo: "Integrante 2 — IR (AST → IR)",
      meta: [
        "Carpeta: src/hc11cc/ir/",
        "Tests: pytest -m ir",
        "Contrato: IR neutral (no conoce HC11)"
      ],
      tareas: [
        { id:"ir-def-1", texto:"Definir estructuras: ModuloIR, FuncionIR, InstrIR", path:"src/hc11cc/ir/ir.py" },
        { id:"ir-def-2", texto:"Instrucciones mínimas: ConstU8, LoadLocal, StoreLocal, AddU8, SubU8, Ret", path:"src/hc11cc/ir/ir.py" },

        { id:"ir-bld-1", texto:"Construir IR desde AST (literales/variables/+/-/return)", path:"src/hc11cc/ir/builder.py" },
        { id:"ir-bld-2", texto:"Contar temporales y locales", path:"src/hc11cc/ir/builder.py" },

        { id:"ir-emit-1", texto:"Imprimir IR legible para debug", path:"src/hc11cc/ir/emit.py" },

        { id:"ir-test-1", texto:"Verificar número de instrucciones y presencia de Ret", path:"tests/miembro2_ir/test_ir_smoke.py" },
      ]
    },
    {
      id: "backend",
      titulo: "Integrante 3 — Backend HC11 (IR → ASM HC11)",
      meta: [
        "Carpeta: src/hc11cc/backend/hc11/",
        "Tests: pytest -m backend",
        "Contrato: generar .asm HC11 válido desde IR"
      ],
      tareas: [
        { id:"be-isa-1", texto:"Definir AsmProgram y representación mínima de instrucciones", path:"src/hc11cc/backend/hc11/isa.py" },

        { id:"be-isel-1", texto:"ConstU8 → LDAA #imm", path:"src/hc11cc/backend/hc11/isel.py" },
        { id:"be-isel-2", texto:"LoadLocal / StoreLocal", path:"src/hc11cc/backend/hc11/isel.py" },
        { id:"be-isel-3", texto:"AddU8 → LDAA lhs,X + ADDA rhs,X + STAA dst,X", path:"src/hc11cc/backend/hc11/isel.py" },
        { id:"be-isel-4", texto:"SubU8 → LDAA lhs,X + SUBA rhs,X + STAA dst,X", path:"src/hc11cc/backend/hc11/isel.py" },
        { id:"be-isel-5", texto:"Ret → RTS", path:"src/hc11cc/backend/hc11/isel.py" },

        { id:"be-abi-1", texto:"ABI v0: ORG, LDS #stack_init, JSR main, halt (RTS/SWI)", path:"src/hc11cc/backend/hc11/program.py" },

        { id:"be-emit-1", texto:"Emitir .asm HC11 con formato consistente", path:"src/hc11cc/backend/hc11/emit.py" },

        { id:"be-test-1", texto:"Verificar asm contiene ORG/LDS/JSR main/RTS", path:"tests/miembro3_backend/test_backend_smoke.py" },
      ]
    },
    {
      id: "integracion",
      titulo: "Integración (pipeline end-to-end)",
      meta: [
        "Archivo: src/hc11cc/driver.py",
        "Tests: pytest -m integracion",
        "Contrato: conectar fases; no meter lógica de fases aquí"
      ],
      tareas: [
        { id:"int-1", texto:"Conectar pipeline: lex → parse → sema → build → select → wrap → emit", path:"src/hc11cc/driver.py" },
        { id:"int-2", texto:"Endurecer smoke test: compilar return 7 y verificar main:/LDAA", path:"tests/integracion/test_pipeline_smoke.py" },
        { id:"int-3", texto:"Acordar contratos mínimos (AST e IR) entre módulos", path:"(acuerdo de equipo)" },
      ]
    }
  ];

  // ----------------------------
  // Persistence
  // ----------------------------
  const KEY = "hc11cc_py_task_state_v1";
  const state = loadState();

  function loadState(){
    try{
      const raw = localStorage.getItem(KEY);
      return raw ? JSON.parse(raw) : {};
    }catch(_){
      return {};
    }
  }
  function saveState(){
    localStorage.setItem(KEY, JSON.stringify(state));
  }

  // ----------------------------
  // Rendering
  // ----------------------------
  const elCards = document.getElementById("cards");
  const elSearch = document.getElementById("search");
  const elScope = document.getElementById("scope");
  const elReset = document.getElementById("reset");
  const elCollapseAll = document.getElementById("collapseAll");
  const elProgressGlobal = document.getElementById("progressGlobal");
  const elDotGlobal = document.getElementById("dotGlobal");

  let collapsed = false;

  function render(){
    const q = (elSearch.value || "").trim().toLowerCase();
    const scope = elScope.value;

    elCards.innerHTML = "";

    let total = 0, done = 0;

    for(const section of DATA){
      if(scope !== "all" && section.id !== scope) continue;

      const card = document.createElement("section");
      card.className = "card" + (scope === "all" ? "" : " span2");

      const head = document.createElement("header");
      const h2 = document.createElement("h2");
      h2.textContent = section.titulo;
      head.appendChild(h2);

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.innerHTML = section.meta.map(x => `<div>${escapeHtml(x)}</div>`).join("");
      head.appendChild(meta);

      const body = document.createElement("div");
      body.className = "body";
      body.style.display = collapsed ? "none" : "block";

      const list = document.createElement("div");

      for(const t of section.tareas){
        const haystack = (t.texto + " " + (t.path || "")).toLowerCase();
        if(q && !haystack.includes(q)) continue;

        total++;
        const checked = !!state[t.id];
        if(checked) done++;

        const row = document.createElement("label");
        row.className = "task" + (checked ? " done" : "");
        row.setAttribute("data-task-id", t.id);

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = checked;
        cb.addEventListener("change", () => {
          state[t.id] = cb.checked;
          saveState();
          render();
        });

        const txt = document.createElement("div");
        txt.className = "txt";
        txt.textContent = t.texto;

        if(t.path){
          const p = document.createElement("span");
          p.className = "path";
          p.textContent = t.path;
          txt.appendChild(p);
        }

        row.appendChild(cb);
        row.appendChild(txt);
        list.appendChild(row);
      }

      body.appendChild(list);

      const footer = document.createElement("div");
      footer.className = "bar";
      footer.style.marginTop = "12px";

      const secStats = statsForSection(section, q);
      const pill = document.createElement("div");
      pill.className = "pill";
      const dot = document.createElement("span");
      dot.className = "dot " + (secStats.done === secStats.total && secStats.total > 0 ? "ok" : (secStats.done > 0 ? "" : "bad"));
      const label = document.createElement("span");
      label.textContent = `${secStats.done}/${secStats.total} completadas`;
      pill.appendChild(dot);
      pill.appendChild(label);

      const hint = document.createElement("div");
      hint.className = "small";
      hint.textContent = "Puedes filtrar por texto o por área para enfocarte en una fase.";

      footer.appendChild(pill);
      footer.appendChild(hint);

      card.appendChild(head);
      card.appendChild(body);
      card.appendChild(footer);

      elCards.appendChild(card);
    }

    elProgressGlobal.textContent = `${done}/${total} completadas`;
    elDotGlobal.className = "dot " + (done === total && total > 0 ? "ok" : (done > 0 ? "" : "bad"));
  }

  function statsForSection(section, q){
    const query = (q || "").trim().toLowerCase();
    let total = 0, done = 0;
    for(const t of section.tareas){
      const haystack = (t.texto + " " + (t.path || "")).toLowerCase();
      if(query && !haystack.includes(query)) continue;
      total++;
      if(state[t.id]) done++;
    }
    return {total, done};
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // ----------------------------
  // Controls
  // ----------------------------
  elSearch.addEventListener("input", render);
  elScope.addEventListener("change", render);

  elReset.addEventListener("click", () => {
    if(!confirm("¿Borrar el progreso guardado en este navegador?")) return;
    for(const k of Object.keys(state)) delete state[k];
    saveState();
    render();
  });

  elCollapseAll.addEventListener("click", () => {
    collapsed = !collapsed;
    elCollapseAll.textContent = collapsed ? "Expandir" : "Colapsar";
    render();
  });

  document.addEventListener("keydown", (e) => {
    if(e.key === "Escape"){
      elSearch.value = "";
      render();
    }
  });

  // Initial
  render();
</script>
</body>
</html>

]
----------------------------------------
File: docs\TASKS.md
[
Comandos para Tests
Frontend. → pytest -m frontend
IR → pytest -m ir
Backend → pytest -m backend
Integración → pytest -m integracion

Integrante 1 — Frontend (lenguaje → AST)

    Objetivo: aceptar el subset del lenguaje y producir un AST válido.

    Implementar src/hc11cc/frontend/lexer.py

        Tokens: fn, main, let, return, u8
        Símbolos: ->, :, =, +, -, (, ), {, }, ;
        Literales enteros 0..255
        Identificadores

    Implementar src/hc11cc/frontend/parser.py

        Función única main
        let x: u8 = <expr>;
        return <expr>;
        Expresiones con + y -, paréntesis

    Implementar src/hc11cc/frontend/sema.py

        Verificación de tipos (u8)
        Error si literal > 255
        Error si variable no existe
        Error si variable se redeclara

    Endurecer tests tests/miembro1_frontend/test_frontend_smoke.py

        Casos válidos
        ≥ 2 casos inválidos (type mismatch, variable no definida)

    Done cuando:
        pytest -m frontend pasa.

Integrante 2 — IR (AST → IR)

    Objetivo: representar la semántica del programa en una IR simple y estable.

    Fase 1 — Base (MVP)

        Definir src/hc11cc/ir/ir.py

            ModuloIR, FuncionIR, InstrIR

        Instrucciones mínimas: ConstU8, LoadLocal, StoreLocal, AddU8, SubU8, Ret

    Implementar src/hc11cc/ir/builder.py

        AST → IR para literales, variables, suma/resta, return

        Conteo de temporales y locales

    Implementar src/hc11cc/ir/emit.py

        Impresión legible de IR para debug

    Endurecer tests tests/miembro2_ir/test_ir_smoke.py

        Verificar número de instrucciones IR
        Verificar presencia de Ret

    Done cuando:
        pytest -m ir pasa.

Integrante 3 — Backend HC11 (IR → ASM HC11)

    Objetivo: generar ensamblador HC11 correcto desde la IR.

    Fase 1 — Base (MVP)

        Definir src/hc11cc/backend/hc11/isa.py
            AsmProgram y representación mínima de instrucciones/operandos

    Implementar src/hc11cc/backend/hc11/isel.py

        ConstU8 → LDAA #imm
        LoadLocal / StoreLocal
        AddU8 → LDAA lhs,X + ADDA rhs,X + STAA dst,X
        SubU8 → LDAA lhs,X + SUBA rhs,X + STAA dst,X
        Ret → RTS

    Implementar src/hc11cc/backend/hc11/program.py (ABI v0)

        ORG
        LDS #stack_init
        JSR main
        halt con RTS o SWI

    Implementar src/hc11cc/backend/hc11/emit.py
        Impresión de .asm HC11

    Endurecer tests tests/miembro3_backend/test_backend_smoke.py
        Verificar que el ASM contenga ORG, LDS, JSR main, RTS

    Done cuando:
        pytest -m backend pasa.

Integración

    Objetivo: que el pipeline completo funcione end-to-end.

    Fase 1 — Humo
        Conectar pipeline en src/hc11cc/driver.py
            lex → parse → sema → build(IR) → select(HC11) → wrap(ABI) → emit(ASM)

        Endurecer tests/integracion/test_pipeline_smoke.py
            Compilar "fn main() -> u8 { return 7; }"
            Verificar que el ASM tenga main: y LDAA

        Acordar contratos entre módulos
            Estructura mínima del AST
            Estructura mínima del IR

    Done cuando:
        pytest -m integracion pasa.

Convenciones del equipo
No tocar módulos ajenos sin avisar.
Integrar solo cuando tu suite local pasa.
Si integración falla: rollback + fix antes de continuar.

]
----------------------------------------
File: error.log
[

=================================== ERRORS ====================================
____________________ ERROR collecting tests/test_parser.py ____________________
ImportError while importing test module 'D:\Coding\Low_Level_Programming\Compilador_HC11\tests\test_parser.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
C:\Python314\Lib\importlib\__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests\test_parser.py:8: in <module>
    from hc11cc.frontend import (
src\hc11cc\__init__.py:1: in <module>
    from .driver import compilar
src\hc11cc\driver.py:4: in <module>
    from hc11cc.frontend.sema import validar
src\hc11cc\frontend\sema.py:2: in <module>
    from .parser import ASTPrograma
E   ImportError: cannot import name 'ASTPrograma' from 'hc11cc.frontend.parser' (D:\Coding\Low_Level_Programming\Compilador_HC11\src\hc11cc\frontend\parser.py)
=========================== short test summary info ===========================
ERROR tests/test_parser.py
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 0.13s

]
----------------------------------------
File: pyproject.toml
[
[project]
name = "hc11cc-py"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = []

[tool.pytest.ini_options]
testpaths = ["tests"]
addopts = "-q"
markers = [
  "frontend: pruebas del frontend",
  "ir: pruebas del IR",
  "backend: pruebas del backend",
  "integracion: pruebas end-to-end"
]

[build-system]
requires = ["setuptools>=68"]
build-backend = "setuptools.build_meta"

]
----------------------------------------
File: src\hc11cc\__init__.py
[
from .driver import compilar
from .config import Config

]
----------------------------------------
File: src\hc11cc\backend\__init__.py
[

]
----------------------------------------
File: src\hc11cc\backend\hc11\__init__.py
[

]
----------------------------------------
File: src\hc11cc\backend\hc11\emit.py
[
from .isa import AsmProgram


def emit_asm(prog: AsmProgram) -> str:
    return "\n".join(prog.lineas) + "\n"

]
----------------------------------------
File: src\hc11cc\backend\hc11\isa.py
[
from dataclasses import dataclass


@dataclass
class AsmProgram:
    lineas: list[str]

]
----------------------------------------
File: src\hc11cc\backend\hc11\isel.py
[
from hc11cc.ir.ir import ModuloIR


def seleccionar(mod: ModuloIR) -> list[str]:
    # Stub: IR → instrucciones virtuales HC11 (texto o estructura)
    return []

]
----------------------------------------
File: src\hc11cc\backend\hc11\program.py
[
from hc11cc.config import Config
from .isa import AsmProgram


def envolver_programa(instrs: list[str], cfg: Config) -> AsmProgram:
    # Stub: prologo ABI (ORG/LDS/JSR main/halt) + cuerpo
    lineas = []
    lineas.append(f"\tORG ${cfg.org:04X}")
    lineas.append("start:")
    lineas.append(f"\tLDS #${cfg.stack_init:04X}")
    lineas.append("\tJSR main")
    lineas.append("halt:")
    lineas.append("\tRTS" if cfg.halt == "rts" else "\tSWI")
    lineas.append("main:")
    lineas.extend(instrs)
    lineas.append("\tEND")
    return AsmProgram(lineas=lineas)

]
----------------------------------------
File: src\hc11cc\config.py
[
from dataclasses import dataclass


@dataclass
class Config:
    emitir_ir: bool = False
    debug: bool = False
    org: int = 0x0100
    stack_init: int = 0x01FF
    halt: str = "rts"  # "rts" o "swi"

]
----------------------------------------
File: src\hc11cc\driver.py
[
from hc11cc.config import Config
from hc11cc.frontend.lexer import lex
from hc11cc.frontend.parser import parse
from hc11cc.frontend.sema import validar
from hc11cc.ir.builder import build
from hc11cc.ir.emit import emit_ir
from hc11cc.backend.hc11.isel import seleccionar
from hc11cc.backend.hc11.program import envolver_programa
from hc11cc.backend.hc11.emit import emit_asm


def compilar(codigo_fuente: str, cfg: Config | None = None) -> str:
    cfg = cfg or Config()

    tokens = lex(codigo_fuente)
    ast = parse(tokens)
    validar(ast)

    modulo_ir = build(ast)

    if cfg.emitir_ir:
        return emit_ir(modulo_ir)

    instrs = seleccionar(modulo_ir)
    asm_prog = envolver_programa(instrs, cfg)
    return emit_asm(asm_prog)

]
----------------------------------------
File: src\hc11cc\errores.py
[
from dataclasses import dataclass
from typing import Optional

# Evitar import circular: no importar Span type checking aquí si no es estrictamente necesario en runtime,
# pero para tipeo lo ideal es `from typing import TYPE_CHECKING`
if False:  # TYPE_CHECKING hack
    from hc11cc.frontend.tokens import Span


class ErrorCompilacion(Exception):
    pass


class ErrorFrontend(ErrorCompilacion):
    def __init__(self, message: str, span: Optional["Span"] = None):
        super().__init__(message)
        self.message = message
        self.span = span

    def __str__(self):
        if self.span:
            return f"{self.message} at {self.span}"
        return self.message


class ErrorIR(ErrorCompilacion):
    pass


class ErrorBackend(ErrorCompilacion):
    pass

]
----------------------------------------
File: src\hc11cc\frontend\__init__.py
[
from .tokens import Token, TokenKind, Span
from .lexer import lex
from .parser import parse
from .ast_nodes import (
    Program,
    Function,
    Stmt,
    Let,
    Return,
    Expr,
    IntLit,
    Var,
    BinOp,
    BinOpKind,
    Type,
    U8,
)


def parse_source(source: str) -> Program:
    tokens = lex(source)
    return parse(tokens)

]
----------------------------------------
File: src\hc11cc\frontend\ast_nodes.py
[
from dataclasses import dataclass
from typing import List, Union
from enum import Enum, auto


@dataclass
class Type:
    name: str

    def __repr__(self):
        return f"Type({self.name})"


U8 = Type("u8")


@dataclass
class Expr:
    pass


@dataclass
class IntLit(Expr):
    val: int


@dataclass
class Var(Expr):
    name: str


class BinOpKind(Enum):
    ADD = auto()
    SUB = auto()


@dataclass
class BinOp(Expr):
    op: BinOpKind
    lhs: Expr
    rhs: Expr


@dataclass
class Stmt:
    pass


@dataclass
class Let(Stmt):
    name: str
    ty: Type
    init: Expr


@dataclass
class Return(Stmt):
    expr: Expr


@dataclass
class Function:
    name: str
    ret_ty: Type
    body: List[Stmt]


@dataclass
class Program:
    functions: List[Function]

]
----------------------------------------
File: src\hc11cc\frontend\lexer.py
[
from .tokens import Token, TokenKind, Span
from hc11cc.errores import ErrorFrontend


def lex(source: str) -> list[Token]:
    tokens = []
    i = 0
    n = len(source)
    line = 1
    col = 1

    # Helper to advance
    def advance(amount=1):
        nonlocal i, col
        i += amount
        col += amount

    # Helper to track newlines
    def newline():
        nonlocal line, col
        line += 1
        col = 1

    KEYWORDS = {
        "fn": TokenKind.FN,
        "main": TokenKind.MAIN,
        "let": TokenKind.LET,
        "return": TokenKind.RETURN,
        "u8": TokenKind.U8,
    }

    while i < n:
        char = source[i]

        # Whitespace
        if char in " \t\r":
            advance()
        elif char == "\n":
            i += 1
            newline()

        # Symbols
        elif char == "(":
            tokens.append(Token(TokenKind.LPAREN, "(", Span(i, i + 1, line, col)))
            advance()
        elif char == ")":
            tokens.append(Token(TokenKind.RPAREN, ")", Span(i, i + 1, line, col)))
            advance()
        elif char == "{":
            tokens.append(Token(TokenKind.LBRACE, "{", Span(i, i + 1, line, col)))
            advance()
        elif char == "}":
            tokens.append(Token(TokenKind.RBRACE, "}", Span(i, i + 1, line, col)))
            advance()
        elif char == ";":
            tokens.append(Token(TokenKind.SEMICOLON, ";", Span(i, i + 1, line, col)))
            advance()
        elif char == ":":
            tokens.append(Token(TokenKind.COLON, ":", Span(i, i + 1, line, col)))
            advance()
        elif char == "=":
            tokens.append(Token(TokenKind.ASSIGN, "=", Span(i, i + 1, line, col)))
            advance()
        elif char == "+":
            tokens.append(Token(TokenKind.PLUS, "+", Span(i, i + 1, line, col)))
            advance()
        elif char == "-":
            # Check for ->
            if i + 1 < n and source[i + 1] == ">":
                tokens.append(Token(TokenKind.ARROW, "->", Span(i, i + 2, line, col)))
                advance(2)
            else:
                tokens.append(Token(TokenKind.MINUS, "-", Span(i, i + 1, line, col)))
                advance()

        # Identifiers and Keywords
        elif char.isalpha() or char == "_":
            start_i = i
            start_col = col
            lexeme = char
            advance()
            while i < n and (source[i].isalnum() or source[i] == "_"):
                lexeme += source[i]
                advance()

            kind = KEYWORDS.get(lexeme, TokenKind.IDENT)
            tokens.append(Token(kind, lexeme, Span(start_i, i, line, start_col)))

        # Integers (decimals)
        elif char.isdigit():
            start_i = i
            start_col = col
            lexeme = char
            advance()
            while i < n and source[i].isdigit():
                lexeme += source[i]
                advance()

            tokens.append(
                Token(
                    TokenKind.INT_LIT,
                    lexeme,
                    Span(start_i, i, line, start_col),
                    int(lexeme),
                )
            )

        else:
            raise ErrorFrontend(
                f"Caracter inesperado '{char}'", Span(i, i + 1, line, col)
            )

    tokens.append(Token(TokenKind.EOF, "", Span(n, n, line, col)))
    return tokens

]
----------------------------------------
File: src\hc11cc\frontend\parser.py
[
from .tokens import Token, TokenKind, Span
from .ast_nodes import (
    Program,
    Function,
    Stmt,
    Let,
    Return,
    Expr,
    IntLit,
    Var,
    BinOp,
    BinOpKind,
    Type,
    U8,
)
from hc11cc.errores import ErrorFrontend


class Parser:
    def __init__(self, tokens: list[Token]):
        self.tokens = tokens
        self.pos = 0

    def current(self) -> Token:
        if self.pos < len(self.tokens):
            return self.tokens[self.pos]
        # Should not happen if EOF is present, but safe fallback
        return self.tokens[-1]

    def advance(self) -> Token:
        t = self.current()
        if self.pos < len(self.tokens):
            self.pos += 1
        return t

    def expect(self, kind: TokenKind) -> Token:
        t = self.current()
        if t.kind == kind:
            return self.advance()
        raise ErrorFrontend(f"Expected {kind.name} got {t.kind.name}", t.span)

    def parse_program(self) -> Program:
        functions = []
        while self.current().kind != TokenKind.EOF:
            functions.append(self.parse_function())
        return Program(functions)

    def parse_function(self) -> Function:
        self.expect(TokenKind.FN)
        if self.current().kind == TokenKind.MAIN:
            name_token = self.advance()
        else:
            name_token = self.expect(TokenKind.IDENT)

        self.expect(TokenKind.LPAREN)
        self.expect(TokenKind.RPAREN)

        # return type: -> u8
        # Optional? Plan implies "-> u8" is part of it.
        # "Un solo main ... Retorno -> u8"
        # "fn main() -> u8"
        self.expect(TokenKind.ARROW)
        self.expect(TokenKind.U8)
        ret_ty = U8

        self.expect(TokenKind.LBRACE)
        body = []
        while (
            self.current().kind != TokenKind.RBRACE
            and self.current().kind != TokenKind.EOF
        ):
            body.append(self.parse_stmt())

        self.expect(TokenKind.RBRACE)
        return Function(name_token.lexeme, ret_ty, body)

    def parse_stmt(self) -> Stmt:
        if self.current().kind == TokenKind.LET:
            return self.parse_let()
        elif self.current().kind == TokenKind.RETURN:
            return self.parse_return()
        else:
            raise ErrorFrontend(
                f"Unexpected token for statement: {self.current().kind}",
                self.current().span,
            )

    def parse_let(self) -> Stmt:
        self.expect(TokenKind.LET)
        name = self.expect(TokenKind.IDENT).lexeme
        self.expect(TokenKind.COLON)
        self.expect(TokenKind.U8)  # Only u8 supported
        self.expect(TokenKind.ASSIGN)
        expr = self.parse_expr()
        self.expect(TokenKind.SEMICOLON)
        return Let(name, U8, expr)

    def parse_return(self) -> Stmt:
        self.expect(TokenKind.RETURN)
        expr = self.parse_expr()
        self.expect(TokenKind.SEMICOLON)
        return Return(expr)

    def parse_expr(self) -> Expr:
        # Expr -> Term { (+|-) Term }
        # Term -> Factor
        # So Expr -> Factor { (+|-) Factor } since we only have + - at same level
        lhs = self.parse_factor()

        while self.current().kind in (TokenKind.PLUS, TokenKind.MINUS):
            op_token = self.advance()
            rhs = self.parse_factor()
            kind = BinOpKind.ADD if op_token.kind == TokenKind.PLUS else BinOpKind.SUB
            lhs = BinOp(kind, lhs, rhs)

        return lhs

    def parse_factor(self) -> Expr:
        t = self.current()
        if t.kind == TokenKind.INT_LIT:
            self.advance()
            return IntLit(t.value)
        elif t.kind == TokenKind.IDENT:
            self.advance()
            return Var(t.lexeme)
        elif t.kind == TokenKind.LPAREN:
            self.advance()
            expr = self.parse_expr()
            self.expect(TokenKind.RPAREN)
            return expr
        else:
            raise ErrorFrontend(f"Unexpected token in expression: {t.kind}", t.span)


def parse(tokens: list[Token]) -> Program:
    parser = Parser(tokens)
    return parser.parse_program()

]
----------------------------------------
File: src\hc11cc\frontend\sema.py
[
from hc11cc.errores import ErrorFrontend
from .ast_nodes import Program


def validar(ast: Program) -> None:
    # Stub: sin reglas todavía.
    # Aquí luego irá: un solo main, tipos u8, literals 0..255, etc.
    return

]
----------------------------------------
File: src\hc11cc\frontend\tokens.py
[
from dataclasses import dataclass
from enum import Enum, auto


@dataclass(frozen=True)
class Span:
    """Represents a range in the source code."""

    start: int  # 0-indexed byte offset
    end: int  # 0-indexed byte offset (exclusive)
    line: int  # 1-indexed line number
    col: int  # 1-indexed column number

    def __post_init__(self):
        if self.end < self.start:
            raise ValueError(f"Invalid span: end ({self.end}) < start ({self.start})")

    def __repr__(self):
        return f"Span({self.line}:{self.col})"


class TokenKind(Enum):
    # Keywords
    FN = auto()
    MAIN = auto()
    LET = auto()
    RETURN = auto()
    U8 = auto()  # Type u8

    # Symbols
    LPAREN = auto()  # (
    RPAREN = auto()  # )
    LBRACE = auto()  # {
    RBRACE = auto()  # }
    SEMICOLON = auto()  # ;
    COLON = auto()  # :
    ASSIGN = auto()  # =
    PLUS = auto()  # +
    MINUS = auto()  # -
    ARROW = auto()  # ->

    # Literals & Identifiers
    IDENT = auto()  # e.g. x, my_var
    INT_LIT = auto()  # e.g. 123

    # Control
    EOF = auto()


@dataclass(frozen=True)
class Token:
    kind: TokenKind
    lexeme: str
    span: Span
    value: int | None = None  # For INT_LIT

    def __repr__(self):
        if self.value is not None:
            return (
                f"Token({self.kind.name}, '{self.lexeme}', {self.value}, {self.span})"
            )
        return f"Token({self.kind.name}, '{self.lexeme}', {self.span})"

]
----------------------------------------
File: src\hc11cc\ir\__init__.py
[

]
----------------------------------------
File: src\hc11cc\ir\builder.py
[
from .ir import ModuloIR
from hc11cc.frontend.ast_nodes import Program


def build(ast: Program) -> ModuloIR:
    # Stub: convertir AST → IR
    return ModuloIR(funciones=[])

]
----------------------------------------
File: src\hc11cc\ir\emit.py
[
from .ir import ModuloIR


def emit_ir(mod: ModuloIR) -> str:
    return "; IR (stub)\n"

]
----------------------------------------
File: src\hc11cc\ir\ir.py
[
from dataclasses import dataclass


@dataclass
class ModuloIR:
    # placeholder
    funciones: list

]
----------------------------------------
File: tests\conftest.py
[
import pytest


@pytest.fixture
def ejemplo_minimo():
    # Por ahora no parsea realmente; sirve para smoke tests.
    return "fn main() -> u8 { return 7; }"

]
----------------------------------------
File: tests\integracion\test_pipeline_smoke.py
[
import pytest
from hc11cc import compilar, Config


@pytest.mark.integracion
def test_pipeline_smoke(ejemplo_minimo):
    cfg = Config(emitir_ir=False)
    asm = compilar(ejemplo_minimo, cfg)
    assert "main:" in asm

]
----------------------------------------
File: tests\miembro1_frontend\test_frontend_smoke.py
[
import pytest
from hc11cc.frontend.lexer import lex
from hc11cc.frontend.parser import parse
from hc11cc.frontend.sema import validar


@pytest.mark.frontend
def test_frontend_smoke(ejemplo_minimo):
    tokens = lex(ejemplo_minimo)
    ast = parse(tokens)
    validar(ast)

]
----------------------------------------
File: tests\miembro2_ir\test_ir_smoke.py
[
import pytest
from hc11cc.frontend.lexer import lex
from hc11cc.frontend.parser import parse
from hc11cc.ir.builder import build


@pytest.mark.ir
def test_ir_smoke(ejemplo_minimo):
    ast = parse(lex(ejemplo_minimo))
    mod = build(ast)
    assert hasattr(mod, "funciones")

]
----------------------------------------
File: tests\miembro3_backend\test_backend_smoke.py
[
import pytest
from hc11cc.config import Config
from hc11cc.backend.hc11.program import envolver_programa
from hc11cc.backend.hc11.emit import emit_asm


@pytest.mark.backend
def test_backend_smoke():
    cfg = Config()
    prog = envolver_programa([], cfg)
    asm = emit_asm(prog)
    assert "ORG" in asm
    assert "LDS" in asm
    assert "JSR main" in asm

]
----------------------------------------
File: tests\test_lexer.py
[
import pytest
import sys
import os

# Ensure src is in path if not installed
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "../src")))

from hc11cc.frontend import lex, TokenKind
from hc11cc.errores import ErrorFrontend


def test_lexer_fn_main():
    source = "fn main() -> u8 { return 7; }"
    tokens = lex(source)

    expected = [
        TokenKind.FN,
        TokenKind.MAIN,
        TokenKind.LPAREN,
        TokenKind.RPAREN,
        TokenKind.ARROW,
        TokenKind.U8,
        TokenKind.LBRACE,
        TokenKind.RETURN,
        TokenKind.INT_LIT,
        TokenKind.SEMICOLON,
        TokenKind.RBRACE,
        TokenKind.EOF,
    ]

    assert len(tokens) == len(expected)
    for t, k in zip(tokens, expected):
        assert t.kind == k

    assert tokens[8].value == 7


def test_lexer_let_assign():
    source = "let x: u8 = 40 + 2;"
    tokens = lex(source)

    # let x : u8 = 40 + 2 ; EOF
    assert tokens[0].kind == TokenKind.LET
    assert tokens[1].kind == TokenKind.IDENT
    assert tokens[1].lexeme == "x"
    assert tokens[2].kind == TokenKind.COLON
    assert tokens[3].kind == TokenKind.U8
    assert tokens[4].kind == TokenKind.ASSIGN
    assert tokens[5].kind == TokenKind.INT_LIT
    assert tokens[5].value == 40
    assert tokens[6].kind == TokenKind.PLUS
    assert tokens[7].kind == TokenKind.INT_LIT
    assert tokens[7].value == 2
    assert tokens[8].kind == TokenKind.SEMICOLON
    assert tokens[9].kind == TokenKind.EOF


def test_lexer_error_unexpected_char():
    source = "let x = @;"
    with pytest.raises(ErrorFrontend) as excinfo:
        lex(source)

    assert "Caracter inesperado '@'" in str(excinfo.value)
    assert excinfo.value.span.line == 1
    # Check column. "let x = " is 8 chars. @ is at index 8 (0-indexed) -> col 9?
    # let is 3, space 1, x 1, space 1, = 1, space 1 = 8 chars.
    # index 01234567
    # "let x = "
    # @ is at 8.
    # So col should be 9 if 1-indexed?
    # My lexer starts col at 1.
    # space updates col.
    # let's trust the logic for now, verifying span roughly.


def test_lexer_spans():
    source = "fn"
    tokens = lex(source)
    t = tokens[0]
    assert t.kind == TokenKind.FN
    assert t.span.start == 0
    assert t.span.end == 2
    assert t.span.line == 1
    assert t.span.col == 1

]
----------------------------------------
File: tests\test_parser.py
[
import pytest
import sys
import os

# Ensure src is in path if not installed
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "../src")))

from hc11cc.frontend import (
    lex,
    parse,
    Program,
    Function,
    Return,
    IntLit,
    Let,
    Var,
    BinOp,
    BinOpKind,
    U8,
)
from hc11cc.errores import ErrorFrontend


def parse_code(code):
    tokens = lex(code)
    return parse(tokens)


def test_parser_basic_return():
    code = "fn main() -> u8 { return 7; }"
    program = parse_code(code)
    assert len(program.functions) == 1
    fn = program.functions[0]
    assert fn.name == "main"
    assert len(fn.body) == 1
    stmt = fn.body[0]
    assert isinstance(stmt, Return)
    assert isinstance(stmt.expr, IntLit)
    assert stmt.expr.val == 7


def test_parser_let_var():
    code = "fn main() -> u8 { let x: u8 = 10; return x; }"
    program = parse_code(code)
    fn = program.functions[0]
    assert len(fn.body) == 2
    let = fn.body[0]
    ret = fn.body[1]

    assert isinstance(let, Let)
    assert let.name == "x"
    assert isinstance(let.init, IntLit)
    assert let.init.val == 10

    assert isinstance(ret, Return)
    assert isinstance(ret.expr, Var)
    assert ret.expr.name == "x"


def test_parser_expr_precedence():
    code = "fn main() -> u8 { return 40 + 2 - 1; }"
    program = parse_code(code)
    # (40 + 2) - 1  (left associative)
    fn = program.functions[0]
    ret = fn.body[0]
    expr = ret.expr  # BinOp(-)

    assert isinstance(expr, BinOp)
    assert expr.op == BinOpKind.SUB
    assert isinstance(expr.rhs, IntLit)
    assert expr.rhs.val == 1

    lhs = expr.lhs  # BinOp(+)
    assert isinstance(lhs, BinOp)
    assert lhs.op == BinOpKind.ADD
    assert isinstance(lhs.lhs, IntLit)
    assert lhs.lhs.val == 40
    assert isinstance(lhs.rhs, IntLit)
    assert lhs.rhs.val == 2


def test_parser_parentheses():
    code = "fn main() -> u8 { return (40 + 2); }"
    program = parse_code(code)
    ret = program.functions[0].body[0]
    # (40+2) is just the BinOp
    expr = ret.expr
    assert isinstance(expr, BinOp)
    assert expr.op == BinOpKind.ADD


def test_parser_error_missing_semicolon():
    code = "fn main() -> u8 { return 7 }"  # Missing ;
    with pytest.raises(ErrorFrontend) as exc:
        parse_code(code)
    assert "Expected SEMICOLON" in str(exc.value)


def test_parser_error_missing_type():
    # Missing explicit type annotation for variable
    # Although grammar requires `let x: u8 = ...`
    code = "fn main() -> u8 { let x = 10; }"
    with pytest.raises(ErrorFrontend) as exc:
        parse_code(code)
    assert "Expected COLON" in str(exc.value)


def test_parse_source_api():
    from hc11cc.frontend import parse_source

    code = "fn main() -> u8 { return 0; }"
    program = parse_source(code)
    assert isinstance(program, Program)
    assert len(program.functions) == 1

]
----------------------------------------
File: tools\OPCIONAL.md
[
Plan de integración: Visualizador/Monitor del compilador (modo “debugger didáctico”)
Objetivo

Agregar una UI (HTML/JS) que permita ver y depurar el compilador por fases, mostrando:

Código fuente (editor)

Artefactos por fase (tokens, AST, IR, ASM, bytes)

Diagnósticos (errores/warnings con ubicación)

Navegación tipo Step / Back / Reset con historial

Sin convertir la UI en “otro compilador”; la UI es un monitor del compilador real.

Decisión de arquitectura (propuesta recomendada)
Enfoque híbrido: Step real + historial cacheado

Step: ejecuta exactamente 1 fase real del compilador si aún no existe el snapshot.

Back/Forward: navega snapshots ya generados (sin recomputar).

El historial es una lista de eventos: trace[].

Ventajas: fidelidad al compilador real + navegación fluida + desacoplamiento limpio.

Contrato de datos (fuente de verdad)

Definir un único tipo de mensaje intercambiado entre compilador y UI:

PipelineEvent

stage: "SOURCE" | "LEX" | "PARSE" | "SEMA" | "IR" | "BACKEND" | "ASM" | "BYTES"

ok: true/false

artifact:

kind: string (ej. "tokens", "ast", "ir", "asm", "bytes")

data: JSON (estructura cruda)

text: string opcional (vista “bonita”)

diagnostics: lista de:

severity: "info" | "warn" | "error"

message: string

span: opcional { line, col, len } (para highlight)

meta: opcional { timeMs, counters, hash }

Regla: la UI renderiza solo desde estos eventos. El compilador nunca toca el DOM.

Comunicación UI ↔ Compilador (dos modos)
Modo recomendado: proceso + stdin/stdout

La UI (o un runner) lanza el compilador como proceso.

La UI manda comandos por stdin:

{"cmd":"reset","source":"..."}

{"cmd":"step"}

{"cmd":"run_all"}

El compilador responde por stdout con PipelineEvent (una línea JSON por evento).

Ventajas: simple, sin servidor, buena para Windows, buena para equipo.

Modo alterno: servidor local + WebSocket

Útil si quieren “modo live” con múltiples clientes.

Más infraestructura.

Pipeline del compilador (para que el monitor exista)

Separar el compilador en fases puras (o casi puras):

LEX(source) -> tokens

PARSE(tokens) -> ast

SEMA(ast) -> ast_validado/tabla símbolos/diagnostics

LOWER(ast) -> ir

BACKEND(ir) -> asm_model

EMIT(asm_model) -> asm_text + bytes

Cada fase produce:

artefacto serializable

diagnostics

status ok/error

Regla: error en una fase detiene el avance (pero el evento de error sí se emite).

Modelo interno del monitor (UI)

Store único (ViewModel):

source: string

trace: PipelineEvent[]

cursor: number (posición actual del usuario en la navegación)

liveStage: number (hasta dónde se ha ejecutado realmente)

playing: boolean

Render:

Panel izquierdo: editor + botones

Panel derecho: pipeline stages + artefacto + diagnostics

Highlight del editor usando span del evento actual (si existe)

Experiencia de usuario (UX) mínima

Controles:

Reset (borra trace, reinicia compilación con el source actual)

Step (genera siguiente evento real si no existe; si existe, navega)

Back / Forward

Run (ejecuta hasta terminar o fallar)

Export trace (descarga JSON de eventos)

Vista:

Etapa activa resaltada

Artefacto mostrado como:

tokens: lista

AST/IR: JSON pretty o tabla

ASM: texto

bytes: hex dump

Diagnostics: lista con severidad

Estrategia de implementación por fases (sin comprometer al equipo)
Fase 0 — “Solo UI” (sin integración)

UI sigue siendo demo.

Define PipelineEvent y el renderer.

Usa “mocks” (eventos falsos) para validar la vista.

Fase 1 — “Modo trace precomputado” (rápido)

compile_all(source) devuelve trace[].

UI solo navega.

Costo bajo, prueba de valor para el equipo.

Fase 2 — “Step real (híbrido)”

Compilador implementa reset/step.

UI manda comandos y recibe eventos en streaming.

Se guarda trace[] igual.

Fase 3 — “Debug real”

Spans precisos (línea/columna)

Modo verbose por fase (contadores, tiempos, dumps)

Export/Import de trace para reproducir bugs

Entregables técnicos (para repartir el trabajo)

Especificación: pipeline_protocol.md (definición de PipelineEvent + comandos)

UI: monitor/index.html (store + renderer + controles)

Driver: tools/monitor_bridge.py o runner equivalente (si se necesita)

Compilador:

compiler/session.py (estado y step())

compiler/phases/\*.py (lex/parse/sema/ir/backend/emit)

compiler/formatters/\*.py (to_text para cada artefacto)

Riesgos y límites (controlados)

Divergencia UI vs compilador: evitada porque la UI no calcula, solo muestra eventos.

Sobrecarga para el equipo: mitigada con “Fase 1” (trace precomputado) antes de “Step real”.

Formato inestable: mitigado con contrato único versionado (protocol_version).

]
----------------------------------------
File: tools\Visualizador_Compilador_HC11.html
[
<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HC11 Language Spec — Visual Compiler Demo (v0)</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1621; --grid:#1a2635; --text:#e7eef7; --muted:#9bb0c5;
      --accent:#7dd3fc; --good:#34d399; --warn:#fbbf24; --bad:#fb7185;
      --shadow: 0 12px 40px rgba(0,0,0,.45);
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:radial-gradient(1000px 600px at 20% 10%, #122033 0%, transparent 55%),
               radial-gradient(800px 500px at 80% 30%, #1b2b3f 0%, transparent 60%),
               var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
    }
    .app{
      height:100vh; display:grid;
      grid-template-columns: 420px 1fr;
      gap:14px; padding:14px;
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      border-radius:18px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .left{
      display:grid;
      grid-template-rows: auto auto auto 1fr auto;
      min-width: 360px;
    }
    .header{
      padding:14px 14px 10px;
      display:flex; align-items:center; justify-content:space-between;
      border-bottom:1px solid rgba(255,255,255,.08);
      gap:10px;
    }
    .header h1{font-size:14px; margin:0; letter-spacing:.35px; color:var(--text); line-height:1.15}
    .header .pill{
      font-size:12px; padding:6px 10px; border-radius:999px;
      background:rgba(125, 211, 252, .12);
      border:1px solid rgba(125, 211, 252, .25);
      color:var(--accent);
      white-space:nowrap;
    }

    .tabs{
      padding:10px 14px;
      display:flex; gap:8px; flex-wrap:wrap;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.10);
    }
    .tab{
      appearance:none; border:none; cursor:pointer;
      border-radius:12px; padding:8px 10px;
      color:var(--muted);
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      transition: background .15s ease, border-color .15s ease;
      font-weight:650; font-size:12.5px;
    }
    .tab.active{
      color: #dbeafe;
      background: rgba(125, 211, 252, .12);
      border-color: rgba(125, 211, 252, .28);
    }

    .controls{
      padding:12px 14px;
      display:flex; gap:10px; flex-wrap:wrap;
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    button{
      appearance:none; border:none; cursor:pointer;
      border-radius:12px; padding:10px 12px;
      color:var(--text);
      background:rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.10);
      transition: transform .08s ease, background .15s ease, border-color .15s ease;
      font-weight:650; font-size:13px;
    }
    button:hover{ background:rgba(255,255,255,.10); border-color:rgba(255,255,255,.18) }
    button:active{ transform: translateY(1px) }
    button.primary{
      background:rgba(52, 211, 153, .12);
      border-color:rgba(52, 211, 153, .28);
      color: #c9ffe8;
    }
    button.danger{
      background:rgba(251, 113, 133, .12);
      border-color:rgba(251, 113, 133, .28);
      color:#ffd0d8;
    }
    button.ghost{
      background:transparent;
      border-color:rgba(255,255,255,.12);
      color:var(--muted);
      font-weight:650;
    }

    .pane{
      padding:12px 14px;
      display:none;
      gap:10px;
      overflow:auto;
    }
    .pane.active{ display:grid; }

    textarea{
      width:100%;
      min-height:170px;
      resize:none;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      color:var(--text);
      padding:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12.6px;
      line-height:1.45;
      outline:none;
    }
    .hint{
      color:var(--muted);
      font-size:12px;
      line-height:1.35;
    }
    .hint code{ color:#dbeafe }

    pre{
      margin:0;
      white-space:pre-wrap;
      overflow:auto;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      padding:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12.2px;
      line-height:1.35;
      color:var(--text);
    }
    .k{ color:#dbeafe }
    .m{ color: rgba(155,176,197,.95) }

    .diagnostics{
      padding:12px 14px;
      border-top:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.18);
      min-height:120px;
    }
    .diag-title{ font-size:12px; color:var(--muted); letter-spacing:.3px; margin-bottom:8px }
    .diag-item{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.04);
      margin-bottom:8px;
      white-space:pre-wrap;
    }
    .diag-item.good{ border-color:rgba(52,211,153,.25); background:rgba(52,211,153,.08) }
    .diag-item.warn{ border-color:rgba(251,191,36,.25); background:rgba(251,191,36,.08) }
    .diag-item.bad{ border-color:rgba(251,113,133,.25); background:rgba(251,113,133,.08) }

    /* Right side */
    .right{
      position:relative;
      display:grid;
      grid-template-rows: 260px 1fr;
      gap:14px;
    }
    .pipeline{
      padding:14px;
      display:flex;
      align-items:center;
      gap:10px;
      overflow:hidden;
    }
    .stage{
      flex:1;
      min-width: 120px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.04);
      padding:12px;
      position:relative;
      transition: transform .15s ease, border-color .15s ease, background .15s ease;
    }
    .stage .name{ font-size:12px; color:var(--muted); margin-bottom:6px; letter-spacing:.3px }
    .stage .desc{ font-size:13px; line-height:1.25; color:var(--text) }
    .stage.active{
      border-color: rgba(125,211,252,.35);
      background: rgba(125,211,252,.08);
      transform: translateY(-2px);
    }
    .stage.done{
      border-color: rgba(52,211,153,.22);
      background: rgba(52,211,153,.06);
    }
    .arrow{
      width:18px; height:18px;
      opacity:.55;
      flex:0 0 auto;
    }

    .viz{
      padding:0;
      position:relative;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      background:
        linear-gradient(transparent 24px, rgba(255,255,255,.04) 25px),
        linear-gradient(90deg, transparent 24px, rgba(255,255,255,.04) 25px),
        radial-gradient(500px 300px at 70% 30%, rgba(125,211,252,.08), transparent 55%),
        radial-gradient(500px 300px at 25% 75%, rgba(52,211,153,.06), transparent 55%),
        rgba(0,0,0,.15);
      background-size: 25px 25px, 25px 25px, auto, auto, auto;
    }

    .overlay{
      position:absolute; inset:14px 14px auto 14px;
      display:flex; gap:12px; align-items:flex-start; pointer-events:none;
    }
    .panel{
      pointer-events:none;
      max-width: 560px;
      padding:12px 14px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.30);
      backdrop-filter: blur(6px);
      box-shadow: var(--shadow);
    }
    .panel .title{
      font-size:12px; color:var(--muted); letter-spacing:.3px; margin-bottom:6px;
      display:flex; align-items:center; justify-content:space-between;
    }
    .panel pre{
      margin:0;
      white-space:pre;
      overflow:auto;
      max-height: 58vh;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12.5px;
      line-height:1.35;
      color:var(--text);
    }
    .badge{
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      color:var(--muted);
    }

    .legend{
      position:absolute; right:14px; top:14px;
      display:flex; flex-direction:column; gap:8px;
      pointer-events:none;
    }
    .legend .row{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      backdrop-filter: blur(6px);
      font-size:12px; color:var(--muted);
      box-shadow: var(--shadow);
      max-width: 300px;
    }
    .dot{ width:10px; height:10px; border-radius:999px; background:rgba(255,255,255,.35) }
    .dot.a{ background: rgba(125,211,252,.8) }
    .dot.g{ background: rgba(52,211,153,.8) }
    .dot.b{ background: rgba(251,113,133,.8) }
  </style>
</head>
<body>
<div class="app">
  <div class="card left">
    <div class="header">
      <h1>HC11 Language Spec — demo visual (v0)</h1>
      <div class="pill">spec → lexer → parser → IR → HC11 asm</div>
    </div>

    <div class="tabs">
      <button class="tab active" data-tab="tab-spec">Especificación</button>
      <button class="tab" data-tab="tab-editor">Editor</button>
      <button class="tab" data-tab="tab-rules">Reglas</button>
    </div>

    <div class="controls">
      <button class="primary" id="btnPlay">Play</button>
      <button id="btnStep">Step</button>
      <button class="ghost" id="btnReset">Reset</button>
      <button class="danger" id="btnInjectErr">Inject error</button>
    </div>

    <div class="pane active" id="tab-spec">
      <pre id="specText"></pre>
      <div class="hint">
        Esto es una <span class="k">visualización</span> del contrato. El compilador real en Python debe coincidir con estas reglas.
      </div>
    </div>

    <div class="pane" id="tab-editor">
      <textarea id="src"></textarea>
      <div class="hint">
        Subconjunto v0:
        <code>fn main() -&gt; u8 { ... }</code>,
        <code>let x: u8 = expr;</code>,
        <code>return expr;</code>,
        <code>+</code>, <code>-</code>, paréntesis, literales <code>0..255</code>.
      </div>
    </div>

    <div class="pane" id="tab-rules">
      <pre id="rulesText"></pre>
      <div class="hint">
        Las reglas semánticas son la capa que “convierte tokens válidos” en “programa válido”.
      </div>
    </div>

    <div class="diagnostics" id="diags">
      <div class="diag-title">Diagnostics</div>
      <div class="diag-item good">Ready. Step o Play para ejecutar el pipeline.</div>
    </div>
  </div>

  <div class="right">
    <div class="card pipeline" id="pipeline"></div>
    <div class="card viz">
      <canvas id="cv"></canvas>

      <div class="overlay">
        <div class="panel" style="flex:1">
          <div class="title">
            <span id="artifactTitle">Artifact</span>
            <span class="badge" id="artifactBadge">SOURCE</span>
          </div>
          <pre id="artifact"></pre>
        </div>
      </div>

      <div class="legend">
        <div class="row"><span class="dot a"></span><span>fase activa</span></div>
        <div class="row"><span class="dot g"></span><span>transformación correcta</span></div>
        <div class="row"><span class="dot b"></span><span>detención por error</span></div>
      </div>
    </div>
  </div>
</div>

<script>
/* ------------- HC11 v0 Spec Visualizer -------------
   Objetivo: enseñar especificación + visualizar transformaciones.
   Pipeline (didáctico):
     0 SOURCE
     1 LEX   (tokens)
     2 PARSE (AST)
     3 SEMA  (validación semántica)
     4 IR    (3-address)
     5 HC11  (asm HC11 mínimo, estilo de tu prototipo)
     6 BYTES (preview: opcode mapping de un subset)
----------------------------------------------------- */

const SPEC = `LANGUAGE SPEC (HC11 v0 / MVP)

Propósito:
- Validar un pipeline completo hacia 68HC11.
- Lenguaje mínimo: main(), u8, let, return, +, -, paréntesis.

Tipos:
- u8 (0..255)

Programa:
- Solo una función: fn main() -> u8 { ... }
- Sin parámetros.
- Debe retornar u8.

Statements:
- let <ident>: u8 = <expr>;
- return <expr>;

Expresiones:
- Literales 0..255
- Variables
- (expr)
- expr + expr
- expr - expr
- Asociatividad: izquierda
- Precedencia: + y - (mismo nivel)
`;

const RULES = `REGLAS SEMÁNTICAS (v0)

1) Literales:
- Un literal fuera de 0..255 es ERROR.

2) Variables:
- Deben declararse antes de usarse.
- No se permite redeclaración en el mismo ámbito (main).

3) Tipos:
- Todo es u8.
- + y - requieren u8 y producen u8.
- (En v0: sin overflow-check; operación modulo 256 es aceptable a nivel máquina.)

4) Retorno:
- main debe contener al menos un return.
- return expr produce un valor u8 en el registro A (por ABI).

5) ABI (resumen didáctico):
- ORG configurable (por defecto $0100).
- Stack init configurable (por defecto $01FF).
- start: LDS #stack; JSR main; halt: RTS|SWI.
- Retorno: A.
`;

const STAGES = [
  { key:"source", name:"Source", desc:"Texto del programa" },
  { key:"lex",    name:"Lexing", desc:"Texto → tokens" },
  { key:"parse",  name:"Parsing", desc:"Tokens → AST" },
  { key:"sema",   name:"Semantic", desc:"AST → validación" },
  { key:"ir",     name:"IR", desc:"AST → IR (3-address)" },
  { key:"hc11",   name:"HC11 asm", desc:"IR → ensamblador HC11" },
  { key:"bytes",  name:"Bytes", desc:"HC11 subset → bytes (preview)" },
];

// ---------- DOM ----------
const dom = {
  src: document.getElementById("src"),
  specText: document.getElementById("specText"),
  rulesText: document.getElementById("rulesText"),
  artifactTitle: document.getElementById("artifactTitle"),
  artifactBadge: document.getElementById("artifactBadge"),
  artifact: document.getElementById("artifact"),
  diags: document.getElementById("diags"),
  pipeline: document.getElementById("pipeline"),
  btnPlay: document.getElementById("btnPlay"),
  btnStep: document.getElementById("btnStep"),
  btnReset: document.getElementById("btnReset"),
  btnInjectErr: document.getElementById("btnInjectErr"),
  cv: document.getElementById("cv"),
};

dom.specText.textContent = SPEC;
dom.rulesText.textContent = RULES;

// Tabs
document.querySelectorAll(".tab").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    document.querySelectorAll(".tab").forEach(b=>b.classList.remove("active"));
    btn.classList.add("active");
    document.querySelectorAll(".pane").forEach(p=>p.classList.remove("active"));
    document.getElementById(btn.dataset.tab).classList.add("active");
  });
});

function setDiag(items){
  dom.diags.innerHTML = `<div class="diag-title">Diagnostics</div>` + items.map(x => {
    const cls = x.sev === "error" ? "bad" : x.sev === "warn" ? "warn" : "good";
    return `<div class="diag-item ${cls}">${escapeHtml(x.msg)}</div>`;
  }).join("");
}
function escapeHtml(s){
  return s.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}
function setArtifact(title, badge, content){
  dom.artifactTitle.textContent = title;
  dom.artifactBadge.textContent = badge;
  dom.artifact.textContent = content;
}

// ---------- Canvas animation ----------
const ctx = dom.cv.getContext("2d");
function resizeCanvas(){
  const r = dom.cv.getBoundingClientRect();
  dom.cv.width = Math.floor(r.width * devicePixelRatio);
  dom.cv.height = Math.floor(r.height * devicePixelRatio);
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

let t0 = performance.now();
function draw(scene){
  const now = performance.now();
  const t = (now - t0) / 1000;

  ctx.clearRect(0,0,dom.cv.width, dom.cv.height);
  const W = dom.cv.width, H = dom.cv.height;
  const ay = H*0.62;

  // flow lines
  const lanes = 7;
  for(let i=0;i<lanes;i++){
    const y = ay + (i - lanes/2)*18*devicePixelRatio;
    const speed = 40 + i*12;
    const phase = (t*speed + i*97) % (W + 300);
    for(let k=0;k<10;k++){
      const x = (phase - k*140) - 150;
      const a = Math.max(0, 0.18 - k*0.012);
      ctx.fillStyle = `rgba(125,211,252,${a})`;
      ctx.fillRect(x, y, 60*devicePixelRatio, 3*devicePixelRatio);
    }
  }

  const pad = 80 * devicePixelRatio;
  const x0 = pad;
  const x1 = W - pad;

  // baseline
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 1*devicePixelRatio;
  ctx.beginPath();
  ctx.moveTo(x0, ay);
  ctx.lineTo(x1, ay);
  ctx.stroke();

  // stage ticks
  for(let i=0;i<STAGES.length;i++){
    const sx = x0 + (x1-x0) * (i/(STAGES.length-1));
    ctx.fillStyle = i <= scene.stageIndex ? "rgba(52,211,153,.25)" : "rgba(255,255,255,.12)";
    ctx.fillRect(sx-1*devicePixelRatio, ay-10*devicePixelRatio, 2*devicePixelRatio, 20*devicePixelRatio);
  }

  // artifact blob
  const prog = scene.flow;
  const ax = x0 + (x1-x0)*prog;

  const glow = 18 + 6*Math.sin(t*3.2);
  const color = scene.status === "error" ? "251,113,133" : scene.status === "ok" ? "52,211,153" : "125,211,252";
  const g = ctx.createRadialGradient(ax, ay, 0, ax, ay, glow*devicePixelRatio);
  g.addColorStop(0, `rgba(${color},0.55)`);
  g.addColorStop(1, `rgba(${color},0)`);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(ax, ay, glow*devicePixelRatio, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = scene.status === "error"
    ? "rgba(251,113,133,.85)"
    : scene.status === "ok"
      ? "rgba(52,211,153,.85)"
      : "rgba(125,211,252,.85)";
  ctx.beginPath();
  ctx.arc(ax, ay, 7*devicePixelRatio, 0, Math.PI*2);
  ctx.fill();
}

// ---------- Compiler core (didáctico) ----------
function CompileError(message){ return { type:"CompileError", message }; }

function isAlpha(ch){ return /[a-zA-Z_]/.test(ch); }
function isDigit(ch){ return /[0-9]/.test(ch); }
function isAlnum(ch){ return /[a-zA-Z0-9_]/.test(ch); }

const KEYWORDS = new Set(["fn","main","let","return","u8"]);
const SYMBOLS = {
  "(": "lpar", ")":"rpar", "{":"lbrace", "}":"rbrace",
  ":":"colon", ";":"semi", "=":"eq", "+":"plus", "-":"minus"
};

function lex(input){
  const tokens = [];
  let i=0, line=1, col=1;

  function push(type, value){
    tokens.push({type, value, line, col});
  }
  function adv(n=1){
    while(n-->0){
      if(input[i]==="\n"){ line++; col=1; i++; }
      else { i++; col++; }
    }
  }

  while(i < input.length){
    const ch = input[i];
    if(ch===" "||ch==="\t"||ch==="\r"||ch==="\n"){ adv(); continue; }

    // arrow ->
    if(ch==="-" && input[i+1]===">"){
      push("arrow","->");
      adv(2);
      continue;
    }

    if(isAlpha(ch)){
      let j=i;
      while(j < input.length && isAlnum(input[j])) j++;
      const word = input.slice(i,j);
      if(KEYWORDS.has(word)) push("kw", word);
      else push("id", word);
      adv(j-i);
      continue;
    }

    if(isDigit(ch)){
      let j=i;
      while(j < input.length && isDigit(input[j])) j++;
      push("num", input.slice(i,j));
      adv(j-i);
      continue;
    }

    const sym = SYMBOLS[ch];
    if(sym){ push(sym, ch); adv(); continue; }

    return { ok:false, error: CompileError(`Unexpected character '${ch}' at ${line}:${col}`) };
  }

  push("eof","<eof>");
  return { ok:true, tokens };
}

// Recursive descent parser according to v0 grammar
function parse(tokens){
  let p=0;
  function peek(){ return tokens[p]; }
  function eat(type, value=null){
    const t = peek();
    if(!t || t.type!==type || (value!==null && t.value!==value)){
      const got = t ? `${t.type}('${t.value}')` : "EOF";
      const exp = value ? `${type}('${value}')` : type;
      return { ok:false, error: CompileError(`Parse error: expected ${exp}, got ${got} at ${t?.line}:${t?.col}`) };
    }
    p++;
    return { ok:true, tok:t };
  }

  // program ::= function
  // function ::= fn main ( ) -> u8 { {stmt} }
  // stmt ::= let_stmt | return_stmt
  // let_stmt ::= let ident : u8 = expr ;
  // return_stmt ::= return expr ;
  // expr ::= factor { (+|-) factor }
  // factor ::= int | ident | ( expr )
  function parseProgram(){
    const fn = parseFunction();
    if(!fn.ok) return fn;
    const eof = eat("eof");
    if(!eof.ok) return eof;
    return { ok:true, ast:{type:"Program", fn: fn.node} };
  }

  function parseFunction(){
    let r;
    r = eat("kw","fn"); if(!r.ok) return r;
    r = eat("kw","main"); if(!r.ok) return r;
    r = eat("lpar","("); if(!r.ok) return r;
    r = eat("rpar",")"); if(!r.ok) return r;
    r = eat("arrow","->"); if(!r.ok) return r;
    r = eat("kw","u8"); if(!r.ok) return r;
    r = eat("lbrace","{"); if(!r.ok) return r;

    const body = [];
    while(peek().type !== "rbrace" && peek().type !== "eof"){
      const st = parseStmt();
      if(!st.ok) return st;
      body.push(st.node);
    }

    r = eat("rbrace","}"); if(!r.ok) return r;
    return { ok:true, node:{type:"Function", name:"main", ret:"u8", body} };
  }

  function parseStmt(){
    const t = peek();
    if(t.type==="kw" && t.value==="let"){
      eat("kw","let");
      const id = eat("id"); if(!id.ok) return id;
      let r = eat("colon",":"); if(!r.ok) return r;
      r = eat("kw","u8"); if(!r.ok) return r;
      r = eat("eq","="); if(!r.ok) return r;
      const ex = parseExpr(); if(!ex.ok) return ex;
      r = eat("semi",";"); if(!r.ok) return r;
      return { ok:true, node:{type:"Let", name:id.tok.value, ty:"u8", expr:ex.node} };
    }
    if(t.type==="kw" && t.value==="return"){
      eat("kw","return");
      const ex = parseExpr(); if(!ex.ok) return ex;
      const r = eat("semi",";"); if(!r.ok) return r;
      return { ok:true, node:{type:"Return", expr:ex.node} };
    }
    return { ok:false, error: CompileError(`Parse error: unexpected token ${t.type}('${t.value}') at ${t.line}:${t.col}`) };
  }

  function parseExpr(){
    let left = parseFactor();
    if(!left.ok) return left;
    while(peek().type==="plus" || peek().type==="minus"){
      const opTok = peek(); p++;
      const right = parseFactor();
      if(!right.ok) return right;
      left = { ok:true, node:{type:"Bin", op:opTok.value, left:left.node, right:right.node} };
    }
    return left;
  }

  function parseFactor(){
    const t = peek();
    if(t.type==="num"){ p++; return { ok:true, node:{type:"Num", value:Number(t.value)} }; }
    if(t.type==="id"){ p++; return { ok:true, node:{type:"Var", name:t.value} }; }
    if(t.type==="lpar"){
      p++;
      const ex = parseExpr(); if(!ex.ok) return ex;
      const r = eat("rpar",")"); if(!r.ok) return r;
      return ex;
    }
    return { ok:false, error: CompileError(`Parse error: expected num/id/'(' at ${t.line}:${t.col}`) };
  }

  return parseProgram();
}

// Semantic checks: literals range, defined vars, redecl, has return
function sema(ast){
  const body = ast.fn.body;
  const defined = new Set();
  let hasReturn = false;

  function checkExpr(e){
    if(e.type==="Num"){
      if(e.value < 0 || e.value > 255) return { ok:false, error: CompileError(`Semantic error: literal ${e.value} outside u8 range (0..255).`) };
      return { ok:true };
    }
    if(e.type==="Var"){
      if(!defined.has(e.name)) return { ok:false, error: CompileError(`Semantic error: variable '${e.name}' used before declaration.`) };
      return { ok:true };
    }
    if(e.type==="Bin"){
      let r = checkExpr(e.left); if(!r.ok) return r;
      r = checkExpr(e.right); if(!r.ok) return r;
      return { ok:true };
    }
    return { ok:false, error: CompileError(`Semantic error: unknown expr node '${e.type}'.`) };
  }

  for(const st of body){
    if(st.type==="Let"){
      if(defined.has(st.name)) return { ok:false, error: CompileError(`Semantic error: variable '${st.name}' redeclared.`) };
      const r = checkExpr(st.expr);
      if(!r.ok) return r;
      defined.add(st.name);
    } else if(st.type==="Return"){
      const r = checkExpr(st.expr);
      if(!r.ok) return r;
      hasReturn = true;
    } else {
      return { ok:false, error: CompileError(`Semantic error: unknown stmt '${st.type}'.`) };
    }
  }

  if(!hasReturn) return { ok:false, error: CompileError("Semantic error: function main must contain at least one return.") };
  return { ok:true, symbols:[...defined] };
}

// Lower to IR (inspired by your Rust prototype ops)
function lowerToIR(ast){
  let temp = 0;
  let local = 0;
  const locals = new Map(); // name -> localId
  const ir = [];

  function newTemp(){ return {kind:"Temp", id: temp++}; }
  function ensureLocal(name){
    if(locals.has(name)) return locals.get(name);
    const id = {kind:"Local", id: local++};
    locals.set(name, id);
    return id;
  }

  function emit(op){ ir.push(op); }

  function lowerExpr(e){
    if(e.type==="Num"){
      const dst = newTemp();
      emit({op:"ConstU8", dst, value:e.value});
      return dst;
    }
    if(e.type==="Var"){
      const dst = newTemp();
      const loc = ensureLocal(e.name);
      emit({op:"LoadLocal", dst, local:loc});
      return dst;
    }
    if(e.type==="Bin"){
      const lhs = lowerExpr(e.left);
      const rhs = lowerExpr(e.right);
      const dst = newTemp();
      emit({op: e.op==="+" ? "AddU8" : "SubU8", dst, lhs, rhs});
      return dst;
    }
    throw new Error("unknown expr");
  }

  for(const st of ast.fn.body){
    if(st.type==="Let"){
      const loc = ensureLocal(st.name);
      const src = lowerExpr(st.expr);
      emit({op:"StoreLocal", local:loc, src});
    } else if(st.type==="Return"){
      const v = lowerExpr(st.expr);
      emit({op:"Ret", value:v});
    }
  }

  return { ok:true, ir, counts:{ locals: local, temps: temp } };
}

// HC11 asm generation (subset like your prototype)
function codegenHC11(ir, cfg){
  // cfg: org, stack, halt
  const org = cfg.org;
  const stack = cfg.stack;
  const halt = cfg.halt;

  // Layout: locals first then temps, both stack slots, indexed by X (TSX).
  // Reserve total_stack = locals + temps bytes.
  // We'll map LocalId and TempId to offsets in [0..255].
  const localsCount = cfg.locals;
  const tempsCount = cfg.temps;
  const total = localsCount + tempsCount;

  function offLocal(id){ return id.id & 0xFF; }
  function offTemp(id){ return (localsCount + id.id) & 0xFF; }

  const asm = [];
  const emit = (s)=>asm.push(s);

  emit(`\tORG $${hex16(org)}`);
  emit(`start:`);
  emit(`\tLDS #$${hex16(stack)}`);
  emit(`\tJSR main`);
  emit(`halt:`);
  emit(halt==="swi" ? `\tSWI` : `\tRTS`);
  emit(`main:`);

  // Prologue: reserve stack bytes
  for(let i=0;i<total;i++) emit(`\tDES`);
  if(total>0) emit(`\tTSX`);

  // Simple codegen: use A as work reg, store all temps/locals in frame.
  for(const ins of ir){
    switch(ins.op){
      case "ConstU8":
        emit(`\tLDAA #$${hex8(ins.value)}`);
        if(total>0){
          emit(`\tSTAA $${hex8(offTemp(ins.dst))},X`);
        }
        break;
      case "LoadLocal":
        emit(`\tLDAA $${hex8(offLocal(ins.local))},X`);
        emit(`\tSTAA $${hex8(offTemp(ins.dst))},X`);
        break;
      case "StoreLocal":
        emit(`\tLDAA $${hex8(offTemp(ins.src))},X`);
        emit(`\tSTAA $${hex8(offLocal(ins.local))},X`);
        break;
      case "AddU8":
        emit(`\tLDAA $${hex8(offTemp(ins.lhs))},X`);
        emit(`\tADDA $${hex8(offTemp(ins.rhs))},X`);
        emit(`\tSTAA $${hex8(offTemp(ins.dst))},X`);
        break;
      case "SubU8":
        emit(`\tLDAA $${hex8(offTemp(ins.lhs))},X`);
        emit(`\tSUBA $${hex8(offTemp(ins.rhs))},X`);
        emit(`\tSTAA $${hex8(offTemp(ins.dst))},X`);
        break;
      case "Ret":
        // load return value into A
        if(total>0) emit(`\tLDAA $${hex8(offTemp(ins.value))},X`);
        // Epilogue: free stack
        for(let i=0;i<total;i++) emit(`\tINS`);
        emit(`\tRTS`);
        break;
      default:
        return { ok:false, error: CompileError(`HC11 codegen: unknown IR op '${ins.op}'.`) };
    }
  }

  emit(`\tEND`);
  return { ok:true, asm };
}

// Byte preview: encode subset of mnemonics (matches your Rust subset)
const OPC = {
  "LDAA_IMM": 0x86,
  "LDAA_IDX": 0xA6,
  "STAA_IDX": 0xA7,
  "ADDA_IDX": 0xAB,
  "SUBA_IDX": 0xA0,
  "LDS_IMM16": 0x8E,
  "JSR": 0xBD,
  "RTS": 0x39,
  "SWI": 0x3F,
  "DES": 0x34,
  "INS": 0x31,
  "TSX": 0x30,
};

function emitBytesPreview(asmLines){
  // Very small encoder: handles lines we generate.
  // Labels + directives ignored. Only the subset above.
  const bytes = [];
  const labels = new Map();
  let pc = null;
  let org = null;

  // pass 1: label addresses + pc
  for(const line of asmLines){
    const s = line.trim();
    if(!s) continue;
    if(s.startsWith("ORG")){
      const addr = parseHex(s.split("$")[1]);
      org = addr; pc = addr;
      continue;
    }
    if(s.endsWith(":")){
      const name = s.slice(0,-1);
      labels.set(name, pc);
      continue;
    }
    if(s === "END") continue;
    if(pc === null) continue;
    pc += instrSize(s, labels);
  }

  // pass 2: encode
  pc = org;
  for(const line of asmLines){
    const raw = line.trim();
    if(!raw) continue;
    if(raw.startsWith("ORG")){
      pc = parseHex(raw.split("$")[1]); // reset
      continue;
    }
    if(raw.endsWith(":") || raw === "END") continue;
    const enc = encodeLine(raw, pc, labels);
    if(enc.error) return { ok:false, error: enc.error };
    bytes.push(...enc.bytes);
    pc += enc.bytes.length;
  }

  return { ok:true, bytes, origin: org ?? 0 };
}

function instrSize(line){
  const s = line.trim();
  if(s==="RTS"||s==="SWI"||s==="DES"||s==="INS"||s==="TSX") return 1;
  if(s.startsWith("LDS #$")) return 3;
  if(s.startsWith("JSR ")) return 3;
  if(s.startsWith("LDAA #$")) return 2;
  if(s.startsWith("LDAA $") && s.includes(",X")) return 2;
  if(s.startsWith("STAA $") && s.includes(",X")) return 2;
  if(s.startsWith("ADDA $") && s.includes(",X")) return 2;
  if(s.startsWith("SUBA $") && s.includes(",X")) return 2;
  // unknown: be strict
  throw new Error("unknown size for: " + s);
}

function encodeLine(line, pc, labels){
  const s = line.trim();
  const out = [];

  try{
    if(s==="RTS"){ out.push(OPC.RTS); return {bytes:out}; }
    if(s==="SWI"){ out.push(OPC.SWI); return {bytes:out}; }
    if(s==="DES"){ out.push(OPC.DES); return {bytes:out}; }
    if(s==="INS"){ out.push(OPC.INS); return {bytes:out}; }
    if(s==="TSX"){ out.push(OPC.TSX); return {bytes:out}; }

    if(s.startsWith("LDS #$")){
      const v = parseHex(s.split("#$")[1]);
      out.push(OPC.LDS_IMM16, (v>>8)&0xFF, v&0xFF);
      return {bytes:out};
    }

    if(s.startsWith("JSR ")){
      const name = s.split(/\s+/)[1];
      const addr = labels.has(name) ? labels.get(name) : parseHex(name.replace("$",""));
      out.push(OPC.JSR, (addr>>8)&0xFF, addr&0xFF);
      return {bytes:out};
    }

    if(s.startsWith("LDAA #$")){
      const v = parseHex(s.split("#$")[1]) & 0xFF;
      out.push(OPC.LDAA_IMM, v);
      return {bytes:out};
    }

    // Indexed forms: $xx,X
    const idxMatch = (mn, opc) => {
      // mn is like "STAA" and line like "STAA $0A,X"
      if(!s.startsWith(mn + " $")) return null;
      if(!s.includes(",X")) return null;
      const part = s.split("$")[1].split(",")[0];
      const off = parseHex(part) & 0xFF;
      return [opc, off];
    };

    let b = idxMatch("LDAA", OPC.LDAA_IDX); if(b){ out.push(...b); return {bytes:out}; }
    b = idxMatch("STAA", OPC.STAA_IDX); if(b){ out.push(...b); return {bytes:out}; }
    b = idxMatch("ADDA", OPC.ADDA_IDX); if(b){ out.push(...b); return {bytes:out}; }
    b = idxMatch("SUBA", OPC.SUBA_IDX); if(b){ out.push(...b); return {bytes:out}; }

    return { error: CompileError("Byte preview: unsupported asm line: " + s) };
  }catch(e){
    return { error: CompileError("Byte preview error: " + (e?.message || String(e))) };
  }
}

// ---------- Formatting ----------
function fmtTokens(tokens){
  return tokens.map(t => `${t.type.padEnd(7)} ${String(t.value).padEnd(8)} @${t.line}:${t.col}`).join("\n");
}
function fmtAST(ast){ return JSON.stringify(ast, null, 2); }
function fmtIR(ir){
  return ir.map((x,i)=>{
    const id = String(i).padStart(2,"0");
    switch(x.op){
      case "ConstU8": return `${id}: ${fmtTemp(x.dst)} = const_u8 ${x.value}`;
      case "LoadLocal": return `${id}: ${fmtTemp(x.dst)} = load_local ${fmtLocal(x.local)}`;
      case "StoreLocal": return `${id}: store_local ${fmtLocal(x.local)}, ${fmtTemp(x.src)}`;
      case "AddU8": return `${id}: ${fmtTemp(x.dst)} = add_u8 ${fmtTemp(x.lhs)}, ${fmtTemp(x.rhs)}`;
      case "SubU8": return `${id}: ${fmtTemp(x.dst)} = sub_u8 ${fmtTemp(x.lhs)}, ${fmtTemp(x.rhs)}`;
      case "Ret": return `${id}: ret ${fmtTemp(x.value)}`;
      default: return `${id}: ${x.op}`;
    }
  }).join("\n");
}
function fmtTemp(t){ return `%t${t.id}`; }
function fmtLocal(l){ return `%l${l.id}`; }
function fmtASM(lines){ return lines.join("\n"); }
function fmtBytes(bytes){
  let out = "";
  for(let i=0;i<bytes.length;i++){
    if(i%16===0) out += (i===0?"":"\n") + String(i).padStart(4,"0") + "  ";
    out += bytes[i].toString(16).padStart(2,"0") + " ";
  }
  return out.trimEnd();
}
function hex8(n){ return (n & 0xFF).toString(16).toUpperCase().padStart(2,"0"); }
function hex16(n){ return (n & 0xFFFF).toString(16).toUpperCase().padStart(4,"0"); }
function parseHex(s){
  const t = s.trim().replace(/^0x/i,"").replace(/^\$/,"");
  return parseInt(t, 16);
}

// ---------- Pipeline runner ----------
const state = {
  stageIndex: 0,
  playing: false,
  flow: 0,
  status: "active",
  cfg: { org: 0x0100, stack: 0x01FF, halt:"rts" },
  artifacts: {
    source: "",
    tokens: null,
    ast: null,
    sema: null,
    ir: null,
    asm: null,
    bytes: null,
  }
};

function renderPipeline(){
  dom.pipeline.innerHTML = "";
  for(let i=0;i<STAGES.length;i++){
    const s = STAGES[i];
    const el = document.createElement("div");
    el.className = "stage" +
      (i === state.stageIndex ? " active" : "") +
      (i < state.stageIndex ? " done" : "");
    el.innerHTML = `<div class="name">${s.name}</div><div class="desc">${s.desc}</div>`;
    dom.pipeline.appendChild(el);
    if(i < STAGES.length-1){
      const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
      svg.setAttribute("class","arrow");
      svg.setAttribute("viewBox","0 0 24 24");
      svg.innerHTML = `<path fill="rgba(255,255,255,.65)" d="M13 5l7 7-7 7v-4H4v-6h9V5z"/>`;
      dom.pipeline.appendChild(svg);
    }
  }
}

function renderStageArtifact(){
  const i = state.stageIndex;
  if(i===0) setArtifact("Source Program","SOURCE", state.artifacts.source);
  else if(i===1) setArtifact("Token Stream","TOKENS", fmtTokens(state.artifacts.tokens||[]));
  else if(i===2) setArtifact("Abstract Syntax Tree (AST)","AST", fmtAST(state.artifacts.ast||{}));
  else if(i===3) setArtifact("Semantic Result","SEMA", JSON.stringify(state.artifacts.sema||{}, null, 2));
  else if(i===4) setArtifact("Intermediate Representation (IR)","IR", fmtIR(state.artifacts.ir||[]));
  else if(i===5) setArtifact("HC11 Assembly (subset)","ASM", fmtASM(state.artifacts.asm||[]));
  else if(i===6) setArtifact("Byte Preview (subset encoder)","BYTES", fmtBytes(state.artifacts.bytes||[]));
}

function resetAll(){
  state.stageIndex = 0;
  state.playing = false;
  state.flow = 0;
  state.status = "active";
  state.artifacts = { source: dom.src.value, tokens:null, ast:null, sema:null, ir:null, asm:null, bytes:null };
  dom.btnPlay.textContent = "Play";
  setDiag([{sev:"info", msg:"Ready. Step o Play para ejecutar el pipeline."}]);
  renderStageArtifact();
  renderPipeline();
}

function stepOnce(){
  if(state.stageIndex >= STAGES.length-1){
    setDiag([{sev:"info", msg:"Pipeline completo."}]);
    state.status = "ok";
    return;
  }
  // stage 0 always reads current editor
  if(state.stageIndex === 0){
    state.artifacts.source = dom.src.value;
  }
  advanceStage();
}

function advanceStage(){
  const next = state.stageIndex + 1;
  const diags = [];

  try{
    if(next === 1){
      const r = lex(state.artifacts.source);
      if(!r.ok) throw r.error;
      state.artifacts.tokens = r.tokens;
      diags.push({sev:"info", msg:`Lexing: ${r.tokens.length} tokens (incluye EOF).`});
    }

    if(next === 2){
      const r = parse(state.artifacts.tokens);
      if(!r.ok) throw r.error;
      state.artifacts.ast = r.ast;
      diags.push({sev:"info", msg:`Parsing: AST construido para main().`});
    }

    if(next === 3){
      const r = sema(state.artifacts.ast);
      if(!r.ok) throw r.error;
      state.artifacts.sema = { ok:true, symbols:r.symbols };
      diags.push({sev:"info", msg:`Sema: OK. Símbolos: ${r.symbols.length ? r.symbols.join(", ") : "(ninguno)"}.`});
    }

    if(next === 4){
      const r = lowerToIR(state.artifacts.ast);
      if(!r.ok) throw r.error;
      state.artifacts.ir = r.ir;
      state.cfg.locals = r.counts.locals;
      state.cfg.temps = r.counts.temps;
      diags.push({sev:"info", msg:`IR: ${r.ir.length} instrs (locals=${r.counts.locals}, temps=${r.counts.temps}).`});
    }

    if(next === 5){
      const r = codegenHC11(state.artifacts.ir, {
        org: state.cfg.org,
        stack: state.cfg.stack,
        halt: state.cfg.halt,
        locals: state.cfg.locals,
        temps: state.cfg.temps
      });
      if(!r.ok) throw r.error;
      state.artifacts.asm = r.asm;
      diags.push({sev:"info", msg:`HC11 asm: emitido (subset).`});
    }

    if(next === 6){
      const r = emitBytesPreview(state.artifacts.asm);
      if(!r.ok) throw r.error;
      state.artifacts.bytes = r.bytes;
      diags.push({sev:"info", msg:`Bytes preview: ${r.bytes.length} bytes, origin=$${hex16(r.origin)}.`});
    }

    state.stageIndex = next;
    state.status = "ok";
    setDiag(diags.length ? diags : [{sev:"info", msg:"Advanced."}]);
    renderStageArtifact();
    renderPipeline();
    animateFlowTo(state.stageIndex / (STAGES.length-1), state.status);
  }catch(err){
    const msg = err?.message || String(err);
    setDiag([{sev:"error", msg}]);
    state.status = "error";
    animateFlowTo(state.stageIndex / (STAGES.length-1), "error");
  }
}

let flowAnim = null;
function animateFlowTo(target, status){
  if(flowAnim) cancelAnimationFrame(flowAnim);
  const start = state.flow;
  const dur = 240;
  const tStart = performance.now();

  function tick(){
    const t = performance.now() - tStart;
    const u = Math.min(1, t/dur);
    const e = 1 - Math.pow(1-u, 3);
    state.flow = start + (target-start)*e;
    state.status = status === "error" ? "error" : "ok";
    draw({ flow: state.flow, stageIndex: state.stageIndex, status: state.status });
    if(u < 1) flowAnim = requestAnimationFrame(tick);
    else flowAnim = null;
  }
  flowAnim = requestAnimationFrame(tick);
}

function loop(){
  if(!flowAnim){
    draw({ flow: state.flow, stageIndex: state.stageIndex, status: state.status === "error" ? "error" : (state.stageIndex===0 ? "active" : "ok") });
  }
  requestAnimationFrame(loop);
}
loop();

// ---------- Controls ----------
dom.btnPlay.addEventListener("click", ()=>{
  state.playing = !state.playing;
  dom.btnPlay.textContent = state.playing ? "Pause" : "Play";
  if(state.playing) playLoop();
});
dom.btnStep.addEventListener("click", ()=>{
  state.playing = false;
  dom.btnPlay.textContent = "Play";
  stepOnce();
});
dom.btnReset.addEventListener("click", resetAll);
dom.btnInjectErr.addEventListener("click", ()=>{
  dom.src.value = `fn main() -> u8 {
  let x: u8 = 300;   // fuera de rango
  return x;
}`;
  resetAll();
  setDiag([{sev:"warn", msg:"Injected error: literal 300 fuera de rango. Observa en qué fase se detecta."}]);
  // switch to editor tab
  document.querySelector('[data-tab="tab-editor"]').click();
});

async function playLoop(){
  while(state.playing){
    if(state.stageIndex >= STAGES.length-1){
      state.playing = false;
      dom.btnPlay.textContent = "Play";
      setDiag([{sev:"info", msg:"Pipeline completo."}]);
      break;
    }
    stepOnce();
    if(state.status === "error"){
      state.playing = false;
      dom.btnPlay.textContent = "Play";
      break;
    }
    await sleep(520);
  }
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

// ---------- Init ----------
dom.src.value =
`fn main() -> u8 {
  let x: u8 = 40;
  let y: u8 = 2;
  return x + y;
}`;

resetAll();
renderPipeline();
renderStageArtifact();
</script>
</body>
</html>

]
----------------------------------------
